<h1>Задание</h1>
<p>
  Необходимо разработать React-приложение для отображения таблицы с данными. Дополнительным плюсом будет: Финальный билд приложения должен быть запускаться из Docker контейнера (хотябы с минимальной конфигурацией)
  
  Для стилизации компонентов подключили 'npm i bootstrap' + scss
</p>

<h2>Функционал</h2>

<p>
<b>  Сортировка по столбцам:</b> при нажатии на название столбца строки таблицы сортируются по возрастанию, при повторном клике — по убыванию. Графическим элементом или текстовым сообщением указывается направление сортировки.
  
 <b> Реализация:</b> С помощью lodash-метода .orderBy,который позволяет указать порядок сортировки итераций для сортировки. Если порядок не указан, все значения сортируются в порядке возрастания.
</p>
//------------------------функция сортировки столбца------

<code>
  sortTableFunc = (sortColumn) => {
  const { data, sort } = this.state;
  const dataCopy = [...data];
  const sortMethod = sort === 'asc' ? 'desc' : 'asc';
  const sortingData = \_.orderBy(dataCopy, sortColumn, sortMethod);
  this.setState({
  data: sortingData,
  sort: sortMethod,
  sortField: sortColumn,
  });
  };

</code>
//----------------------------------------------------------------------------------------------------------------------

<b>Клиентская пагинация: </b>данные необходимо отображать постранично, максимум 50 элементов на страницу.
Необходимо предоставить пользовательскую навигацию для перехода по страницам.

<b>Реализация:</b>

<p>
  - Используем npm i react-paginate;
  - свойство в стейте currentPage(текущая страница)
  - свойство pageSize(размер страницы,по заданию pageSize:50)
  - lodash.chunk -Создает массив элементов, разбитых на группы по длине размера. Если массив не может быть разделен равномерно, то последним фрагментом будут оставшиеся элементы.

</p>  
//---------------------------------
<code>
  onPageChange = ({ selected }) => {
  this.setState({ currentPage: selected });
  };
</code>
//-------------------------------------

<code>
  {data.length > pageSize ? (
  <ReactPaginate
  previousLabel={'previous'}
  nextLabel={'next'}
  breakLabel={'...'}
  breakClassName={'break-me'}
  pageCount={pageCount}
  marginPagesDisplayed={2}
  initialPage={1}
  pageRangeDisplayed={10}
  onPageChange={this.onPageChange}
  containerClassName={'pagination'}
  activeClassName={'active'}
  pageClassName="page-item"
  pageLinkClassName="page-link"
  previousClassName="page-item"
  nextClassName="page-item"
  previousLinkClassName="page-link"
  nextLinkClassName="page-link"
  forcePage={this.state.currentPage}
  />
  ) : null}
</code>

//---------------------------------------------
<code>const displayData = \_.chunk(visibleItems, pageSize)[currentPage];</code> // видимые элементы таблицы с учетом текущей страницы
//------------------------------------------------------------------------------------------------------------------------

<p>
  <b>Фильтрация:</b> компонент предоставляет текстовое поле, в которое пользователь может ввести текст и строки таблицы, данные которых не содержат подстроку, введённую пользователем, скрываются. Перефильтрация осуществляется по нажатию на кнопку "Найти".

</p>  
<p>
  <b>Реализация:</b>
  -Используем "контролируемое" свойство в стейте "filterStr: '' "(Значение value в поле input)
  -Кнопку "Найти" делать не стал. Поиск осуществляется по событию onChange в поле <input>
  -Функция searchFilter принимает первым аргументом массив данных,вторым значение поля "filterStr"
  -вывод
</p>

//----------------------------поиск/фильтрация элементов------------------
<code>
onSearchChange = (filterStr) => {
this.setState({ filterStr });
};

searchFilter = (items, filterStr) => {
if (filterStr === 0) {
return items;
}
return items.filter((item) => {
return (
item.firstName.toLowerCase().indexOf(filterStr.toLowerCase()) > -1 ||
item.lastName.toLowerCase().indexOf(filterStr.toLowerCase()) > -1 ||
item.email.toLowerCase().indexOf(filterStr.toLowerCase()) > -1 ||
item.phone.toLowerCase().indexOf(filterStr.toLowerCase()) > -1
);
});
};
</code>
//--------------------------------------------
<code>const visibleItems = this.searchFilter(data, filterStr);</code> //видимые элементы массива
//------------------------------------------------------------------------------------------------------------------------

<p>По клику на строку таблицы значения полей выводятся в дополнительном блоке под таблицей.</p>

<b>Реализация:</b>

<p>
  - В стейте новое свойство - 'userSelected: null'
  - На каждый элемент в таблице навешиваем функцию viewUserInfo
</p>
  //-------------Вывод детальной информации о пользователе ----------
<code>
    viewUserInfo = (elem) => {
    this.setState({
    userSelected: elem,
    });
    };
</code>
  //------------------------------------------
<p>  При клике на элемент таблицы открывается компонент UserInfo внизу таблицы.</p>
  //-----------------------------------------------------------------------------------------------------------------------

<p>Данные в таблицу загружаются с сервера filltext.com посредством метода fetch().</p>
//-----------------------------------------------------------------------------------------------------------------------

<p>
  Над таблицей присутсвует кнопка добавить, по нажатию на которую выпадает форма добавления ряда +------+------------+-----------------+-----------------+---------------+ | id | firstName | lastName | email | phone | +------+------------+-----------------+-----------------+---------------+ |input | input | input | input | input | +------+------------+-----------------+-----------------+---------------+
  После заполнения всех инпутов активируется кнопка Добавить в таблицу которая вставляет заполненный ряд в начало таблицы

</p>  
<b>Реализация:</b>

<p>
  - используем флаг isOpenForm
  - используем функцию toggleOpenForm
</p>
  //----------------------Кнопка "добавить" -------------------
<code>
    toggleOpenForm = () => {
    this.setState((state) => ({ isFormOpen: !state.isFormOpen }));
    };
</code>
  //--------------------------------------
<p>  По клику флаг меняется на true и на экран выводится форма AddUser.</p>
  //------------------------------------------------------------------------------------------------------------------------
<p>
    Для демонстрации работы компонента необходимо сделать простую HTML страницу. Пользователю предлагается выбрать набор данных: маленький или большой. При выборе набора данных он загружается с сервера и по данным строится таблица.

</p>  
 <b> Реализация:</b>
<p>
    На главном экране выведено 2 кнопки: "32 элемента" и "1000 элементов".
    По нажатию на кнопку выводится соответствующее количество элементов в таблицу.
</p>
  //------------------------------------------------------------------------------------------------------------------------
