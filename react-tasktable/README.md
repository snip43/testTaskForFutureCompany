<h4>Задание</h4>
Необходимо разработать React-приложение для отображения таблицы с данными. Дополнительным плюсом будет: Финальный билд приложения должен быть запускаться из Docker контейнера (хотябы с минимальной конфигурацией)

Для стилизации компонентов подключили 'npm i bootstrap' + scss

Функционал

Сортировка по столбцам: при нажатии на название столбца строки таблицы сортируются по возрастанию, при повторном клике — по убыванию. Графическим элементом или текстовым сообщением указывается направление сортировки.

Реализация: С помощью lodash-метода .orderBy,который позволяет указать порядок сортировки итераций для сортировки. Если порядок не указан, все значения сортируются в порядке возрастания.
//------------------------функция сортировки столбца------

sortTableFunc = (sortColumn) => {
const { data, sort } = this.state;
const dataCopy = [...data];
const sortMethod = sort === 'asc' ? 'desc' : 'asc';
const sortingData = \_.orderBy(dataCopy, sortColumn, sortMethod);
this.setState({
data: sortingData,
sort: sortMethod,
sortField: sortColumn,
});
};

//----------------------------------------------------------------------------------------------------------------------

Клиентская пагинация: данные необходимо отображать постранично, максимум 50 элементов на страницу.
Необходимо предоставить пользовательскую навигацию для перехода по страницам.

Реализация:

- Используем npm i react-paginate;
- свойство в стейте currentPage(текущая страница)
- свойство pageSize(размер страницы,по заданию pageSize:50)
- lodash.chunk -Создает массив элементов, разбитых на группы по длине размера. Если массив не может быть разделен равномерно, то последним фрагментом будут оставшиеся элементы.

//---------------------------------
onPageChange = ({ selected }) => {
this.setState({ currentPage: selected });
};
//-------------------------------------

{data.length > pageSize ? (
<ReactPaginate
previousLabel={'previous'}
nextLabel={'next'}
breakLabel={'...'}
breakClassName={'break-me'}
pageCount={pageCount}
marginPagesDisplayed={2}
initialPage={1}
pageRangeDisplayed={10}
onPageChange={this.onPageChange}
containerClassName={'pagination'}
activeClassName={'active'}
pageClassName="page-item"
pageLinkClassName="page-link"
previousClassName="page-item"
nextClassName="page-item"
previousLinkClassName="page-link"
nextLinkClassName="page-link"
forcePage={this.state.currentPage}
/>
) : null}

//---------------------------------------------
const displayData = \_.chunk(visibleItems, pageSize)[currentPage]; // видимые элементы таблицы с учетом текущей страницы
//------------------------------------------------------------------------------------------------------------------------

Фильтрация: компонент предоставляет текстовое поле, в которое пользователь может ввести текст и строки таблицы, данные которых не содержат подстроку, введённую пользователем, скрываются. Перефильтрация осуществляется по нажатию на кнопку "Найти".

Реализация:
-Используем "контролируемое" свойство в стейте "filterStr: '' "(Значение value в поле input)
-Кнопку "Найти" делать не стал. Поиск осуществляется по событию onChange в поле <input>
-Функция searchFilter принимает первым аргументом массив данных,вторым значение поля "filterStr"
-вывод

//----------------------------поиск/фильтрация элементов------------------
onSearchChange = (filterStr) => {
this.setState({ filterStr });
};

searchFilter = (items, filterStr) => {
if (filterStr === 0) {
return items;
}
return items.filter((item) => {
return (
item.firstName.toLowerCase().indexOf(filterStr.toLowerCase()) > -1 ||
item.lastName.toLowerCase().indexOf(filterStr.toLowerCase()) > -1 ||
item.email.toLowerCase().indexOf(filterStr.toLowerCase()) > -1 ||
item.phone.toLowerCase().indexOf(filterStr.toLowerCase()) > -1
);
});
};
//--------------------------------------------
const visibleItems = this.searchFilter(data, filterStr); //видимые элементы массива
//------------------------------------------------------------------------------------------------------------------------

По клику на строку таблицы значения полей выводятся в дополнительном блоке под таблицей.

Реализация:

- В стейте новое свойство - 'userSelected: null'
- На каждый элемент в таблице навешиваем функцию viewUserInfo
  //-------------Вывод детальной информации о пользователе ----------
  viewUserInfo = (elem) => {
  this.setState({
  userSelected: elem,
  });
  };
  //------------------------------------------
  При клике на элемент таблицы открывается компонент UserInfo внизу таблицы.
  //-----------------------------------------------------------------------------------------------------------------------

Данные в таблицу загружаются с сервера filltext.com посредством метода fetch().
//-----------------------------------------------------------------------------------------------------------------------

Над таблицей присутсвует кнопка добавить, по нажатию на которую выпадает форма добавления ряда +------+------------+-----------------+-----------------+---------------+ | id | firstName | lastName | email | phone | +------+------------+-----------------+-----------------+---------------+ |input | input | input | input | input | +------+------------+-----------------+-----------------+---------------+
После заполнения всех инпутов активируется кнопка Добавить в таблицу которая вставляет заполненный ряд в начало таблицы

Реализация:

- используем флаг isOpenForm
- используем функцию toggleOpenForm
  //----------------------Кнопка "добавить" -------------------
  toggleOpenForm = () => {
  this.setState((state) => ({ isFormOpen: !state.isFormOpen }));
  };
  //--------------------------------------
  По клику флаг меняется на true и на экран выводится форма AddUser.
  //------------------------------------------------------------------------------------------------------------------------
  Для демонстрации работы компонента необходимо сделать простую HTML страницу. Пользователю предлагается выбрать набор данных: маленький или большой. При выборе набора данных он загружается с сервера и по данным строится таблица.

  Реализация:
  На главном экране выведено 2 кнопки: "32 элемента" и "1000 элементов".
  По нажатию на кнопку выводится соответствующее количество элементов в таблицу.
  //------------------------------------------------------------------------------------------------------------------------
