<h1>Задание</h1>
<p>
  Необходимо разработать React-приложение для отображения таблицы с данными. Дополнительным плюсом будет: Финальный билд приложения должен быть запускаться из Docker контейнера (хотябы с минимальной конфигурацией)
  Для стилизации компонентов подключили 'npm i bootstrap' + scss
</p>

<h2>Функционал</h2>
<p>
<b>  Сортировка по столбцам:</b> при нажатии на название столбца строки таблицы сортируются по возрастанию, при повторном клике — по убыванию. Графическим элементом или текстовым сообщением указывается направление сортировки.
<b> Реализация:</b> С помощью lodash-метода .orderBy,который позволяет указать порядок сортировки итераций для сортировки. Если порядок не указан, все значения сортируются в порядке возрастания.
</p>
<pre>
//------------------------функция сортировки столбца------
    sortTableFunc = (sortColumn) => {
    const { data, sort } = this.state;
    const dataCopy = [...data];
    const sortMethod = sort === 'asc' ? 'desc' : 'asc';
    const sortingData = \_.orderBy(dataCopy, sortColumn, sortMethod);
    this.setState({
    data: sortingData,
    sort: sortMethod,
    sortField: sortColumn,
    });
    };
//----------------------------------------------------------------------------------------------------------------------
</pre>

<b>Клиентская пагинация: </b>данные необходимо отображать постранично, максимум 50 элементов на страницу.
Необходимо предоставить пользовательскую навигацию для перехода по страницам.

<b>Реализация:</b>

<ul>
  <li>- Используем npm i react-paginate;</li>
   <li> - свойство в стейте currentPage(текущая страница)</li>
   <li> - свойство pageSize(размер страницы,по заданию pageSize:50)</li>
   <li> - lodash.chunk -Создает массив элементов, разбитых на группы по длине размера. Если массив не может быть разделен равномерно, то последним фрагментом будут оставшиеся элементы.</li>
</ul>
<pre>
  //---------------------------------
    onPageChange = ({ selected }) => {
    this.setState({ currentPage: selected });
    };
  //-------------------------------------
    {data.length > pageSize ? (
    <ReactPaginate
    previousLabel={'previous'}
    nextLabel={'next'}
    breakLabel={'...'}
    breakClassName={'break-me'}
    pageCount={pageCount}
    marginPagesDisplayed={2}
    initialPage={1}
    pageRangeDisplayed={10}
    onPageChange={this.onPageChange}
    containerClassName={'pagination'}
    activeClassName={'active'}
    pageClassName="page-item"
    pageLinkClassName="page-link"
    previousClassName="page-item"
    nextClassName="page-item"
    previousLinkClassName="page-link"
    nextLinkClassName="page-link"
    forcePage={this.state.currentPage}
    />
    ) : null}
  //---------------------------------------------
  const displayData = \_.chunk(visibleItems, pageSize)[currentPage]; // видимые элементы таблицы с учетом текущей страницы
  //------------------------------------------------------------------------------------------------------------------------

</pre>

<p>
  <b>Фильтрация:</b> компонент предоставляет текстовое поле, в которое пользователь может ввести текст и строки таблицы, данные которых не содержат подстроку, введённую пользователем, скрываются. Перефильтрация осуществляется по нажатию на кнопку "Найти".
</p>  
  <b>Реализация:</b>
<ul>
    <li>-Используем "контролируемое" свойство в стейте "filterStr: '' "(Значение value в поле input)</li>
    <li>-Кнопку "Найти" делать не стал. Поиск осуществляется по событию onChange в поле <input></li>
    <li>-Функция searchFilter принимает первым аргументом массив данных,вторым значение поля "filterStr"</li>
</ul>

<pre>
  //----------------------------поиск/фильтрация элементов------------------
  onSearchChange = (filterStr) => {
  this.setState({ filterStr });
  };
  
  searchFilter = (items, filterStr) => {
  if (filterStr === 0) {
  return items;
  }
  return items.filter((item) => {
  return (
  item.firstName.toLowerCase().indexOf(filterStr.toLowerCase()) > -1 ||
  item.lastName.toLowerCase().indexOf(filterStr.toLowerCase()) > -1 ||
  item.email.toLowerCase().indexOf(filterStr.toLowerCase()) > -1 ||
  item.phone.toLowerCase().indexOf(filterStr.toLowerCase()) > -1
  );
  });
  };
  
  //--------------------------------------------
  const visibleItems = this.searchFilter(data, filterStr); //видимые элементы массива
  //------------------------------------------------------------------------------------------------------------------------

</pre>

<p>По клику на строку таблицы значения полей выводятся в дополнительном блоке под таблицей.</p>
<b>Реализация:</b>
<ul>
  <li>- В стейте новое свойство - 'userSelected: null'</li>
 <li> - На каждый элемент в таблице навешиваем функцию viewUserInfo</li>
</ul>
<pre>
//-------------Вывод детальной информации о пользователе ----------
  viewUserInfo = (elem) => {
  this.setState({
  userSelected: elem,
  });
  };
//------------------------------------------
</pre>

<p>  При клике на элемент таблицы открывается компонент UserInfo внизу таблицы.</p>
//-----------------------------------------------------------------------------------------------------------------------
<p>Данные в таблицу загружаются с сервера filltext.com посредством метода fetch().</p>
//-----------------------------------------------------------------------------------------------------------------------
<p>
  Над таблицей присутсвует кнопка добавить, по нажатию на которую выпадает форма добавления ряда +------+------------+-----------------+-----------------+---------------+ | id | firstName | lastName | email | phone | +------+------------+-----------------+-----------------+---------------+ |input | input | input | input | input | +------+------------+-----------------+-----------------+---------------+
  После заполнения всех инпутов активируется кнопка Добавить в таблицу которая вставляет заполненный ряд в начало таблицы
</p>  
<b>Реализация:</b>
<ul>
  <li>- используем флаг isOpenForm</li>
  <li>- используем функцию toggleOpenForm</li>
</ul>

<pre>
  //----------------------Кнопка "добавить" -------------------
  toggleOpenForm = () => {
      this.setState((state) => ({ isFormOpen: !state.isFormOpen }));
      };
  //--------------------------------------
</pre>

<p>  По клику флаг меняется на true и на экран выводится форма AddUser.</p>
  //------------------------------------------------------------------------------------------------------------------------
<p>
    Для демонстрации работы компонента необходимо сделать простую HTML страницу. Пользователю предлагается выбрать набор данных: маленький или большой. При выборе набора данных он загружается с сервера и по данным строится таблица.
</p>  
 <b> Реализация:</b>
<p>
    На главном экране выведено 2 кнопки: "32 элемента" и "1000 элементов".
    По нажатию на кнопку выводится соответствующее количество элементов в таблицу.
</p>
  //------------------------------------------------------------------------------------------------------------------------
